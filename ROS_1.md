ROS(Robot Operating System)
===
- OS(Operating System) : 컴퓨터 하드웨어와 응용소프트웨어 사이를 중재하며 하드웨어를 제어하고 응용소프트웨어를 위한 기반 환경 제공.
- ROS : The Robot Operating System is a flexible framework for writing robot software. It is a collection of tools, libraries and conventions that aim to simplify the task of creating complex and robust robot behavior across a wide variety of robot platforms.
- 로봇을 동작시키는 소프트웨어를 만드는 복잡하고 어려운 공정을 쉽게 할 수 있도록 여러 가지 도구나 라이브러리들을 모아 놓은 개발환경.
- 2010 ~ 2020년까지 총 13개의 버전 공개.
- 2017년부터 ROS1을 개선하고 정리하여 ROS2가 공개.
- 표윤석 박사님 ros 강의자료 link <https://github.com/robotpilot/ros-seminar>
- 표윤석 박사님 ros 블로그 link <https://m.blog.naver.com/passionvirus/80129744379>

ROS 프로그램의 구성
---------------

## 로봇이나 자율주행에 관련된 소프트웨어 작성할 경우
```cpp
while(1){
  라이더의 신호 입력
  카메라의 신호 입력
  판단
  로봇 제어
}
```
- 입력 신호들을 이용하여 어떻게 행동할지 판단
- 그에 따라 적절히 로봇이나 자율주행차를 제어해야 함(무한 반복)

### 로봇 소프트웨어 작성의 문제점
1. 각 부분의 동작 순서를 결정하기 어려울 때가 있음.
  * 데이터의 의존성을 고려해야 한다.
    - 어느 부분을 먼저 수행해야 하는가에 대한 조건이 있을 수 있음.
  * 조건이 복잡하게 얽히면 각 프로그램 부분의 수행 순서를 정하는 것이 쉽지 않음. 
2. 각 부분마다 수행되는 주기가 다름.
  * 라이다 신호가 생성되는 주기와 카메라 신호가 생성되는 주기가 서로 다를 수 있음.
  * 제어 신호를 만드는 주기도 서로 다를 수 있음.
  * 전체의 수행 주기를 어떻게 할지도 고민해야 함.
3. 각 부분 사이의 데이터 전달을 위한 데이터 형식이 서로 다름.
  * 라이다의 데이터, 카메라의 데이터, 로봇에 대한 제어 데이터들은 모두 서로 다른 특성과 형식을 가지고 있음.
  * 전체 프로그램을 작성 시 서로 다른 형식들을 모두 고려해야 함.
  * 이러한 문제들은 소프트웨어의 각 부분을 자신이 작성하는 것이 아니라 외부의 라이브러리를 이용하면 더욱더 심각해짐.
    - 보통 라이더, 카메라, 로봇들은 구매해서 이용.
    - 해당 기기를 제작한 회사에서 그에 해당하는 프로그램 라이브러리를 제공 및 이용.
    - 소프트웨어 안의 각종 알고리즘이나 기능들도 새로 개발하는 것도 어렵기 때문에 이미 공개된 것을 이용하는 경우 많음.
따라서 로봇 소프트웨어를 만드는 입장에서는 라이브러리를 이용해서 전체 소프트웨어를 작성할텐데 각 라이브러리마다의 서로 다른 실행 주기, 데이터 형식을 고려해야하므로 쉽지 않음.

**<u>즉 독립적으로 개발되고 공개된 라이브러리들을 모아서 하나의 로봇 소프트웨어를 개발하는데 체계적으로 통합할 수 있는 프레임워크로 만들어진 것이 ROS이다.</u>**

## ROS의 구성 - 노드(Node)
* 기본적인 프로그램의 단위.
  - 부분적인 실행/중단/교체가 용이함.
* 각각의 노드들은 독립적으로 개발.
* 병렬적, 독립적으로 실행.
  - 전체 실행 주기에 대해 고려할 필요가 없음.
  - 각 노드들을 서로 다른 언어로 개발 가능.
  - 각 노드가 서로 다른 기기에서 동작 가능.
* 각 노드 사이의 데이터 교환을 위해 통일적인 노드 인터페이스를 제공함.
* 전체 소프트웨어를 통합할 때 각 부분의 특성을 세세하게 고려할 필요가 적어짐.
전체 소프트웨어의 통합이 용이하게 됨.

### 인터페이스.  

   * 메시지(Message): 메시지는 노드간의 주고 받는 데이터. 메시지는 int, float, point, bool형 등과 같은 변수 형태이다. 또한, 메시지 안에 메시지를 품고 있는 간단한 데이터 구조 및 메시지들의 배열과 같은 구조도 사용할 수 있다.
   * 토픽(Topic): 정의된 자료형을 가지고 메시지 스트림으로서 단방향 전송.     
    - (노드 1) -----> (노드 2)
      + 토픽 발행(Publish): 송신.
      + 토픽 구독(Subscribe): 수신.
      + publisher(odometry) -> 위치 정보(x, y, 𝜃) -> subscriber(SLAM).
      + publisher(거리 센서) -> 장애물(x, y) -> subscriber(로봇 A, 로봇 B).
      + 1:1, 1:N, N:1, N:N 가능.
   
   * 서비스(Service): 동기식 양방향 메시지 통신.   
    - (노드1) <-----> (노드 2)
      + 클라이언트(Client): 서비스 요청.
      + 서버(Server): 서비스 응답. 
      + 동기식: 클라이언트에서는 서비스를 요청한 다음에 응답이 올 때까지 대기하게 되며, 서비스 서버에서는 서비스 요청을 받았을 때 되도록 즉시 응답한다는 의미.
      + 이러한 특성으로 인해 상태 질의, 환경 설정 관리와 같은 간단한 읽기/쓰기에 상호작용에 적합.
      + But, 시간이 오래걸리는 작업에는 부적합.(ex, 로봇의 이동)

   * 액션(Action): 비동기식 양방향 메시지 통신.    
    - (노드1) 목표--> <--피드백, 결과 (노드2)
      + 로봇의 이동과 같은 오랜 시간이 걸리는 작업에 적합.
      + 한 노드에서 목표를 전송하면 다른 노드에서 그 목표를 이루는 행동을 하고 목표를 이루면 그 결과를 회신함. 목표에 따라 행동하는 도중에 피드백을 제공해 주기도 함.
      + 액션 클라이언트(Client): 목표를 요청. 
      + 액션 서버(Server): 목표에 따라 행동하는 노드.

